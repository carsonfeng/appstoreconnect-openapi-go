/*
 * App Store Connect API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package appstoreopenapi

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// BuildsApiService BuildsApi service
type BuildsApiService service

// BuildsApiBuildsAppEncryptionDeclarationGetToOneRelatedOpts Optional parameters for the method 'BuildsAppEncryptionDeclarationGetToOneRelated'
type BuildsApiBuildsAppEncryptionDeclarationGetToOneRelatedOpts struct {
	FieldsAppEncryptionDeclarations optional.Interface
}

/*
BuildsAppEncryptionDeclarationGetToOneRelated Method for BuildsAppEncryptionDeclarationGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsAppEncryptionDeclarationGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsAppEncryptionDeclarations" (optional.Interface of []string) -  the fields to include for returned resources of type appEncryptionDeclarations
@return AppEncryptionDeclarationResponse
*/
func (a *BuildsApiService) BuildsAppEncryptionDeclarationGetToOneRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsAppEncryptionDeclarationGetToOneRelatedOpts) (AppEncryptionDeclarationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppEncryptionDeclarationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/appEncryptionDeclaration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsAppEncryptionDeclarations.IsSet() {
		localVarQueryParams.Add("fields[appEncryptionDeclarations]", parameterToString(localVarOptionals.FieldsAppEncryptionDeclarations.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
BuildsAppEncryptionDeclarationGetToOneRelationship Method for BuildsAppEncryptionDeclarationGetToOneRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
@return BuildAppEncryptionDeclarationLinkageResponse
*/
func (a *BuildsApiService) BuildsAppEncryptionDeclarationGetToOneRelationship(ctx _context.Context, id string) (BuildAppEncryptionDeclarationLinkageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildAppEncryptionDeclarationLinkageResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/relationships/appEncryptionDeclaration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
BuildsAppEncryptionDeclarationUpdateToOneRelationship Method for BuildsAppEncryptionDeclarationUpdateToOneRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param buildAppEncryptionDeclarationLinkageRequest Related linkage
*/
func (a *BuildsApiService) BuildsAppEncryptionDeclarationUpdateToOneRelationship(ctx _context.Context, id string, buildAppEncryptionDeclarationLinkageRequest BuildAppEncryptionDeclarationLinkageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/relationships/appEncryptionDeclaration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &buildAppEncryptionDeclarationLinkageRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// BuildsApiBuildsAppGetToOneRelatedOpts Optional parameters for the method 'BuildsAppGetToOneRelated'
type BuildsApiBuildsAppGetToOneRelatedOpts struct {
	FieldsApps optional.Interface
}

/*
BuildsAppGetToOneRelated Method for BuildsAppGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsAppGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
@return AppResponse
*/
func (a *BuildsApiService) BuildsAppGetToOneRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsAppGetToOneRelatedOpts) (AppResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/app"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsAppStoreVersionGetToOneRelatedOpts Optional parameters for the method 'BuildsAppStoreVersionGetToOneRelated'
type BuildsApiBuildsAppStoreVersionGetToOneRelatedOpts struct {
	FieldsAppStoreVersions optional.Interface
}

/*
BuildsAppStoreVersionGetToOneRelated Method for BuildsAppStoreVersionGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsAppStoreVersionGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsAppStoreVersions" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersions
@return AppStoreVersionResponse
*/
func (a *BuildsApiService) BuildsAppStoreVersionGetToOneRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsAppStoreVersionGetToOneRelatedOpts) (AppStoreVersionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/appStoreVersion"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersions.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(localVarOptionals.FieldsAppStoreVersions.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsBetaAppReviewSubmissionGetToOneRelatedOpts Optional parameters for the method 'BuildsBetaAppReviewSubmissionGetToOneRelated'
type BuildsApiBuildsBetaAppReviewSubmissionGetToOneRelatedOpts struct {
	FieldsBetaAppReviewSubmissions optional.Interface
}

/*
BuildsBetaAppReviewSubmissionGetToOneRelated Method for BuildsBetaAppReviewSubmissionGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsBetaAppReviewSubmissionGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsBetaAppReviewSubmissions" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppReviewSubmissions
@return BetaAppReviewSubmissionResponse
*/
func (a *BuildsApiService) BuildsBetaAppReviewSubmissionGetToOneRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsBetaAppReviewSubmissionGetToOneRelatedOpts) (BetaAppReviewSubmissionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaAppReviewSubmissionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/betaAppReviewSubmission"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppReviewSubmissions.IsSet() {
		localVarQueryParams.Add("fields[betaAppReviewSubmissions]", parameterToString(localVarOptionals.FieldsBetaAppReviewSubmissions.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsBetaBuildLocalizationsGetToManyRelatedOpts Optional parameters for the method 'BuildsBetaBuildLocalizationsGetToManyRelated'
type BuildsApiBuildsBetaBuildLocalizationsGetToManyRelatedOpts struct {
	FieldsBetaBuildLocalizations optional.Interface
	Limit                        optional.Int32
}

/*
BuildsBetaBuildLocalizationsGetToManyRelated Method for BuildsBetaBuildLocalizationsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsBetaBuildLocalizationsGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsBetaBuildLocalizations" (optional.Interface of []string) -  the fields to include for returned resources of type betaBuildLocalizations
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return BetaBuildLocalizationsResponse
*/
func (a *BuildsApiService) BuildsBetaBuildLocalizationsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsBetaBuildLocalizationsGetToManyRelatedOpts) (BetaBuildLocalizationsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaBuildLocalizationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/betaBuildLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBetaBuildLocalizations.IsSet() {
		localVarQueryParams.Add("fields[betaBuildLocalizations]", parameterToString(localVarOptionals.FieldsBetaBuildLocalizations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
BuildsBetaGroupsCreateToManyRelationship Method for BuildsBetaGroupsCreateToManyRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param buildBetaGroupsLinkagesRequest List of related linkages
*/
func (a *BuildsApiService) BuildsBetaGroupsCreateToManyRelationship(ctx _context.Context, id string, buildBetaGroupsLinkagesRequest BuildBetaGroupsLinkagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/relationships/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &buildBetaGroupsLinkagesRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
BuildsBetaGroupsDeleteToManyRelationship Method for BuildsBetaGroupsDeleteToManyRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param buildBetaGroupsLinkagesRequest List of related linkages
*/
func (a *BuildsApiService) BuildsBetaGroupsDeleteToManyRelationship(ctx _context.Context, id string, buildBetaGroupsLinkagesRequest BuildBetaGroupsLinkagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/relationships/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &buildBetaGroupsLinkagesRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// BuildsApiBuildsBuildBetaDetailGetToOneRelatedOpts Optional parameters for the method 'BuildsBuildBetaDetailGetToOneRelated'
type BuildsApiBuildsBuildBetaDetailGetToOneRelatedOpts struct {
	FieldsBuildBetaDetails optional.Interface
}

/*
BuildsBuildBetaDetailGetToOneRelated Method for BuildsBuildBetaDetailGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsBuildBetaDetailGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsBuildBetaDetails" (optional.Interface of []string) -  the fields to include for returned resources of type buildBetaDetails
@return BuildBetaDetailResponse
*/
func (a *BuildsApiService) BuildsBuildBetaDetailGetToOneRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsBuildBetaDetailGetToOneRelatedOpts) (BuildBetaDetailResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildBetaDetailResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/buildBetaDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBuildBetaDetails.IsSet() {
		localVarQueryParams.Add("fields[buildBetaDetails]", parameterToString(localVarOptionals.FieldsBuildBetaDetails.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsDiagnosticSignaturesGetToManyRelatedOpts Optional parameters for the method 'BuildsDiagnosticSignaturesGetToManyRelated'
type BuildsApiBuildsDiagnosticSignaturesGetToManyRelatedOpts struct {
	FilterDiagnosticType       optional.Interface
	FieldsDiagnosticSignatures optional.Interface
	Limit                      optional.Int32
}

/*
BuildsDiagnosticSignaturesGetToManyRelated Method for BuildsDiagnosticSignaturesGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsDiagnosticSignaturesGetToManyRelatedOpts - Optional Parameters:
 * @param "FilterDiagnosticType" (optional.Interface of []string) -  filter by attribute 'diagnosticType'
 * @param "FieldsDiagnosticSignatures" (optional.Interface of []string) -  the fields to include for returned resources of type diagnosticSignatures
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return DiagnosticSignaturesResponse
*/
func (a *BuildsApiService) BuildsDiagnosticSignaturesGetToManyRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsDiagnosticSignaturesGetToManyRelatedOpts) (DiagnosticSignaturesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DiagnosticSignaturesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/diagnosticSignatures"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FilterDiagnosticType.IsSet() {
		localVarQueryParams.Add("filter[diagnosticType]", parameterToString(localVarOptionals.FilterDiagnosticType.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsDiagnosticSignatures.IsSet() {
		localVarQueryParams.Add("fields[diagnosticSignatures]", parameterToString(localVarOptionals.FieldsDiagnosticSignatures.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsGetCollectionOpts Optional parameters for the method 'BuildsGetCollection'
type BuildsApiBuildsGetCollectionOpts struct {
	FilterBetaAppReviewSubmissionBetaReviewState optional.Interface
	FilterExpired                                optional.Interface
	FilterPreReleaseVersionPlatform              optional.Interface
	FilterPreReleaseVersionVersion               optional.Interface
	FilterProcessingState                        optional.Interface
	FilterUsesNonExemptEncryption                optional.Interface
	FilterVersion                                optional.Interface
	FilterApp                                    optional.Interface
	FilterAppStoreVersion                        optional.Interface
	FilterBetaGroups                             optional.Interface
	FilterPreReleaseVersion                      optional.Interface
	FilterId                                     optional.Interface
	Sort                                         optional.Interface
	FieldsBuilds                                 optional.Interface
	Limit                                        optional.Int32
	Include                                      optional.Interface
	FieldsAppEncryptionDeclarations              optional.Interface
	FieldsBetaAppReviewSubmissions               optional.Interface
	FieldsBuildBetaDetails                       optional.Interface
	FieldsBuildIcons                             optional.Interface
	FieldsPerfPowerMetrics                       optional.Interface
	FieldsPreReleaseVersions                     optional.Interface
	FieldsAppStoreVersions                       optional.Interface
	FieldsDiagnosticSignatures                   optional.Interface
	FieldsBetaTesters                            optional.Interface
	FieldsBetaBuildLocalizations                 optional.Interface
	FieldsApps                                   optional.Interface
	LimitBetaBuildLocalizations                  optional.Int32
	LimitIcons                                   optional.Int32
	LimitIndividualTesters                       optional.Int32
}

/*
BuildsGetCollection Method for BuildsGetCollection
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *BuildsApiBuildsGetCollectionOpts - Optional Parameters:
 * @param "FilterBetaAppReviewSubmissionBetaReviewState" (optional.Interface of []string) -  filter by attribute 'betaAppReviewSubmission.betaReviewState'
 * @param "FilterExpired" (optional.Interface of []string) -  filter by attribute 'expired'
 * @param "FilterPreReleaseVersionPlatform" (optional.Interface of []string) -  filter by attribute 'preReleaseVersion.platform'
 * @param "FilterPreReleaseVersionVersion" (optional.Interface of []string) -  filter by attribute 'preReleaseVersion.version'
 * @param "FilterProcessingState" (optional.Interface of []string) -  filter by attribute 'processingState'
 * @param "FilterUsesNonExemptEncryption" (optional.Interface of []string) -  filter by attribute 'usesNonExemptEncryption'
 * @param "FilterVersion" (optional.Interface of []string) -  filter by attribute 'version'
 * @param "FilterApp" (optional.Interface of []string) -  filter by id(s) of related 'app'
 * @param "FilterAppStoreVersion" (optional.Interface of []string) -  filter by id(s) of related 'appStoreVersion'
 * @param "FilterBetaGroups" (optional.Interface of []string) -  filter by id(s) of related 'betaGroups'
 * @param "FilterPreReleaseVersion" (optional.Interface of []string) -  filter by id(s) of related 'preReleaseVersion'
 * @param "FilterId" (optional.Interface of []string) -  filter by id(s)
 * @param "Sort" (optional.Interface of []string) -  comma-separated list of sort expressions; resources will be sorted as specified
 * @param "FieldsBuilds" (optional.Interface of []string) -  the fields to include for returned resources of type builds
 * @param "Limit" (optional.Int32) -  maximum resources per page
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
 * @param "FieldsAppEncryptionDeclarations" (optional.Interface of []string) -  the fields to include for returned resources of type appEncryptionDeclarations
 * @param "FieldsBetaAppReviewSubmissions" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppReviewSubmissions
 * @param "FieldsBuildBetaDetails" (optional.Interface of []string) -  the fields to include for returned resources of type buildBetaDetails
 * @param "FieldsBuildIcons" (optional.Interface of []string) -  the fields to include for returned resources of type buildIcons
 * @param "FieldsPerfPowerMetrics" (optional.Interface of []string) -  the fields to include for returned resources of type perfPowerMetrics
 * @param "FieldsPreReleaseVersions" (optional.Interface of []string) -  the fields to include for returned resources of type preReleaseVersions
 * @param "FieldsAppStoreVersions" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersions
 * @param "FieldsDiagnosticSignatures" (optional.Interface of []string) -  the fields to include for returned resources of type diagnosticSignatures
 * @param "FieldsBetaTesters" (optional.Interface of []string) -  the fields to include for returned resources of type betaTesters
 * @param "FieldsBetaBuildLocalizations" (optional.Interface of []string) -  the fields to include for returned resources of type betaBuildLocalizations
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "LimitBetaBuildLocalizations" (optional.Int32) -  maximum number of related betaBuildLocalizations returned (when they are included)
 * @param "LimitIcons" (optional.Int32) -  maximum number of related icons returned (when they are included)
 * @param "LimitIndividualTesters" (optional.Int32) -  maximum number of related individualTesters returned (when they are included)
@return BuildsResponse
*/
func (a *BuildsApiService) BuildsGetCollection(ctx _context.Context, localVarOptionals *BuildsApiBuildsGetCollectionOpts) (BuildsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FilterBetaAppReviewSubmissionBetaReviewState.IsSet() {
		localVarQueryParams.Add("filter[betaAppReviewSubmission.betaReviewState]", parameterToString(localVarOptionals.FilterBetaAppReviewSubmissionBetaReviewState.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterExpired.IsSet() {
		localVarQueryParams.Add("filter[expired]", parameterToString(localVarOptionals.FilterExpired.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterPreReleaseVersionPlatform.IsSet() {
		localVarQueryParams.Add("filter[preReleaseVersion.platform]", parameterToString(localVarOptionals.FilterPreReleaseVersionPlatform.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterPreReleaseVersionVersion.IsSet() {
		localVarQueryParams.Add("filter[preReleaseVersion.version]", parameterToString(localVarOptionals.FilterPreReleaseVersionVersion.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterProcessingState.IsSet() {
		localVarQueryParams.Add("filter[processingState]", parameterToString(localVarOptionals.FilterProcessingState.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterUsesNonExemptEncryption.IsSet() {
		localVarQueryParams.Add("filter[usesNonExemptEncryption]", parameterToString(localVarOptionals.FilterUsesNonExemptEncryption.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterVersion.IsSet() {
		localVarQueryParams.Add("filter[version]", parameterToString(localVarOptionals.FilterVersion.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterApp.IsSet() {
		localVarQueryParams.Add("filter[app]", parameterToString(localVarOptionals.FilterApp.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterAppStoreVersion.IsSet() {
		localVarQueryParams.Add("filter[appStoreVersion]", parameterToString(localVarOptionals.FilterAppStoreVersion.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterBetaGroups.IsSet() {
		localVarQueryParams.Add("filter[betaGroups]", parameterToString(localVarOptionals.FilterBetaGroups.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterPreReleaseVersion.IsSet() {
		localVarQueryParams.Add("filter[preReleaseVersion]", parameterToString(localVarOptionals.FilterPreReleaseVersion.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterId.IsSet() {
		localVarQueryParams.Add("filter[id]", parameterToString(localVarOptionals.FilterId.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBuilds.IsSet() {
		localVarQueryParams.Add("fields[builds]", parameterToString(localVarOptionals.FieldsBuilds.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppEncryptionDeclarations.IsSet() {
		localVarQueryParams.Add("fields[appEncryptionDeclarations]", parameterToString(localVarOptionals.FieldsAppEncryptionDeclarations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppReviewSubmissions.IsSet() {
		localVarQueryParams.Add("fields[betaAppReviewSubmissions]", parameterToString(localVarOptionals.FieldsBetaAppReviewSubmissions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBuildBetaDetails.IsSet() {
		localVarQueryParams.Add("fields[buildBetaDetails]", parameterToString(localVarOptionals.FieldsBuildBetaDetails.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBuildIcons.IsSet() {
		localVarQueryParams.Add("fields[buildIcons]", parameterToString(localVarOptionals.FieldsBuildIcons.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsPerfPowerMetrics.IsSet() {
		localVarQueryParams.Add("fields[perfPowerMetrics]", parameterToString(localVarOptionals.FieldsPerfPowerMetrics.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsPreReleaseVersions.IsSet() {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(localVarOptionals.FieldsPreReleaseVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersions.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(localVarOptionals.FieldsAppStoreVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsDiagnosticSignatures.IsSet() {
		localVarQueryParams.Add("fields[diagnosticSignatures]", parameterToString(localVarOptionals.FieldsDiagnosticSignatures.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaTesters.IsSet() {
		localVarQueryParams.Add("fields[betaTesters]", parameterToString(localVarOptionals.FieldsBetaTesters.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaBuildLocalizations.IsSet() {
		localVarQueryParams.Add("fields[betaBuildLocalizations]", parameterToString(localVarOptionals.FieldsBetaBuildLocalizations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.LimitBetaBuildLocalizations.IsSet() {
		localVarQueryParams.Add("limit[betaBuildLocalizations]", parameterToString(localVarOptionals.LimitBetaBuildLocalizations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitIcons.IsSet() {
		localVarQueryParams.Add("limit[icons]", parameterToString(localVarOptionals.LimitIcons.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitIndividualTesters.IsSet() {
		localVarQueryParams.Add("limit[individualTesters]", parameterToString(localVarOptionals.LimitIndividualTesters.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsGetInstanceOpts Optional parameters for the method 'BuildsGetInstance'
type BuildsApiBuildsGetInstanceOpts struct {
	FieldsBuilds                    optional.Interface
	Include                         optional.Interface
	FieldsAppEncryptionDeclarations optional.Interface
	FieldsBetaAppReviewSubmissions  optional.Interface
	FieldsBuildBetaDetails          optional.Interface
	FieldsBuildIcons                optional.Interface
	FieldsPerfPowerMetrics          optional.Interface
	FieldsPreReleaseVersions        optional.Interface
	FieldsAppStoreVersions          optional.Interface
	FieldsDiagnosticSignatures      optional.Interface
	FieldsBetaTesters               optional.Interface
	FieldsBetaBuildLocalizations    optional.Interface
	FieldsApps                      optional.Interface
	LimitBetaBuildLocalizations     optional.Int32
	LimitIcons                      optional.Int32
	LimitIndividualTesters          optional.Int32
}

/*
BuildsGetInstance Method for BuildsGetInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsGetInstanceOpts - Optional Parameters:
 * @param "FieldsBuilds" (optional.Interface of []string) -  the fields to include for returned resources of type builds
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
 * @param "FieldsAppEncryptionDeclarations" (optional.Interface of []string) -  the fields to include for returned resources of type appEncryptionDeclarations
 * @param "FieldsBetaAppReviewSubmissions" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppReviewSubmissions
 * @param "FieldsBuildBetaDetails" (optional.Interface of []string) -  the fields to include for returned resources of type buildBetaDetails
 * @param "FieldsBuildIcons" (optional.Interface of []string) -  the fields to include for returned resources of type buildIcons
 * @param "FieldsPerfPowerMetrics" (optional.Interface of []string) -  the fields to include for returned resources of type perfPowerMetrics
 * @param "FieldsPreReleaseVersions" (optional.Interface of []string) -  the fields to include for returned resources of type preReleaseVersions
 * @param "FieldsAppStoreVersions" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersions
 * @param "FieldsDiagnosticSignatures" (optional.Interface of []string) -  the fields to include for returned resources of type diagnosticSignatures
 * @param "FieldsBetaTesters" (optional.Interface of []string) -  the fields to include for returned resources of type betaTesters
 * @param "FieldsBetaBuildLocalizations" (optional.Interface of []string) -  the fields to include for returned resources of type betaBuildLocalizations
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "LimitBetaBuildLocalizations" (optional.Int32) -  maximum number of related betaBuildLocalizations returned (when they are included)
 * @param "LimitIcons" (optional.Int32) -  maximum number of related icons returned (when they are included)
 * @param "LimitIndividualTesters" (optional.Int32) -  maximum number of related individualTesters returned (when they are included)
@return BuildResponse
*/
func (a *BuildsApiService) BuildsGetInstance(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsGetInstanceOpts) (BuildResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBuilds.IsSet() {
		localVarQueryParams.Add("fields[builds]", parameterToString(localVarOptionals.FieldsBuilds.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppEncryptionDeclarations.IsSet() {
		localVarQueryParams.Add("fields[appEncryptionDeclarations]", parameterToString(localVarOptionals.FieldsAppEncryptionDeclarations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppReviewSubmissions.IsSet() {
		localVarQueryParams.Add("fields[betaAppReviewSubmissions]", parameterToString(localVarOptionals.FieldsBetaAppReviewSubmissions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBuildBetaDetails.IsSet() {
		localVarQueryParams.Add("fields[buildBetaDetails]", parameterToString(localVarOptionals.FieldsBuildBetaDetails.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBuildIcons.IsSet() {
		localVarQueryParams.Add("fields[buildIcons]", parameterToString(localVarOptionals.FieldsBuildIcons.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsPerfPowerMetrics.IsSet() {
		localVarQueryParams.Add("fields[perfPowerMetrics]", parameterToString(localVarOptionals.FieldsPerfPowerMetrics.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsPreReleaseVersions.IsSet() {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(localVarOptionals.FieldsPreReleaseVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersions.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(localVarOptionals.FieldsAppStoreVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsDiagnosticSignatures.IsSet() {
		localVarQueryParams.Add("fields[diagnosticSignatures]", parameterToString(localVarOptionals.FieldsDiagnosticSignatures.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaTesters.IsSet() {
		localVarQueryParams.Add("fields[betaTesters]", parameterToString(localVarOptionals.FieldsBetaTesters.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaBuildLocalizations.IsSet() {
		localVarQueryParams.Add("fields[betaBuildLocalizations]", parameterToString(localVarOptionals.FieldsBetaBuildLocalizations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.LimitBetaBuildLocalizations.IsSet() {
		localVarQueryParams.Add("limit[betaBuildLocalizations]", parameterToString(localVarOptionals.LimitBetaBuildLocalizations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitIcons.IsSet() {
		localVarQueryParams.Add("limit[icons]", parameterToString(localVarOptionals.LimitIcons.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitIndividualTesters.IsSet() {
		localVarQueryParams.Add("limit[individualTesters]", parameterToString(localVarOptionals.LimitIndividualTesters.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsIconsGetToManyRelatedOpts Optional parameters for the method 'BuildsIconsGetToManyRelated'
type BuildsApiBuildsIconsGetToManyRelatedOpts struct {
	FieldsBuildIcons optional.Interface
	Limit            optional.Int32
}

/*
BuildsIconsGetToManyRelated Method for BuildsIconsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsIconsGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsBuildIcons" (optional.Interface of []string) -  the fields to include for returned resources of type buildIcons
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return BuildIconsResponse
*/
func (a *BuildsApiService) BuildsIconsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsIconsGetToManyRelatedOpts) (BuildIconsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildIconsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/icons"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBuildIcons.IsSet() {
		localVarQueryParams.Add("fields[buildIcons]", parameterToString(localVarOptionals.FieldsBuildIcons.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
BuildsIndividualTestersCreateToManyRelationship Method for BuildsIndividualTestersCreateToManyRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param buildIndividualTestersLinkagesRequest List of related linkages
*/
func (a *BuildsApiService) BuildsIndividualTestersCreateToManyRelationship(ctx _context.Context, id string, buildIndividualTestersLinkagesRequest BuildIndividualTestersLinkagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/relationships/individualTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &buildIndividualTestersLinkagesRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
BuildsIndividualTestersDeleteToManyRelationship Method for BuildsIndividualTestersDeleteToManyRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param buildIndividualTestersLinkagesRequest List of related linkages
*/
func (a *BuildsApiService) BuildsIndividualTestersDeleteToManyRelationship(ctx _context.Context, id string, buildIndividualTestersLinkagesRequest BuildIndividualTestersLinkagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/relationships/individualTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &buildIndividualTestersLinkagesRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// BuildsApiBuildsIndividualTestersGetToManyRelatedOpts Optional parameters for the method 'BuildsIndividualTestersGetToManyRelated'
type BuildsApiBuildsIndividualTestersGetToManyRelatedOpts struct {
	FieldsBetaTesters optional.Interface
	Limit             optional.Int32
}

/*
BuildsIndividualTestersGetToManyRelated Method for BuildsIndividualTestersGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsIndividualTestersGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsBetaTesters" (optional.Interface of []string) -  the fields to include for returned resources of type betaTesters
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return BetaTestersResponse
*/
func (a *BuildsApiService) BuildsIndividualTestersGetToManyRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsIndividualTestersGetToManyRelatedOpts) (BetaTestersResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaTestersResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/individualTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBetaTesters.IsSet() {
		localVarQueryParams.Add("fields[betaTesters]", parameterToString(localVarOptionals.FieldsBetaTesters.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsIndividualTestersGetToManyRelationshipOpts Optional parameters for the method 'BuildsIndividualTestersGetToManyRelationship'
type BuildsApiBuildsIndividualTestersGetToManyRelationshipOpts struct {
	Limit optional.Int32
}

/*
BuildsIndividualTestersGetToManyRelationship Method for BuildsIndividualTestersGetToManyRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsIndividualTestersGetToManyRelationshipOpts - Optional Parameters:
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return BuildIndividualTestersLinkagesResponse
*/
func (a *BuildsApiService) BuildsIndividualTestersGetToManyRelationship(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsIndividualTestersGetToManyRelationshipOpts) (BuildIndividualTestersLinkagesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildIndividualTestersLinkagesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/relationships/individualTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsPerfPowerMetricsGetToManyRelatedOpts Optional parameters for the method 'BuildsPerfPowerMetricsGetToManyRelated'
type BuildsApiBuildsPerfPowerMetricsGetToManyRelatedOpts struct {
	FilterDeviceType optional.Interface
	FilterMetricType optional.Interface
	FilterPlatform   optional.Interface
}

/*
BuildsPerfPowerMetricsGetToManyRelated Method for BuildsPerfPowerMetricsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsPerfPowerMetricsGetToManyRelatedOpts - Optional Parameters:
 * @param "FilterDeviceType" (optional.Interface of []string) -  filter by attribute 'deviceType'
 * @param "FilterMetricType" (optional.Interface of []string) -  filter by attribute 'metricType'
 * @param "FilterPlatform" (optional.Interface of []string) -  filter by attribute 'platform'
@return PerfPowerMetricsResponse
*/
func (a *BuildsApiService) BuildsPerfPowerMetricsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsPerfPowerMetricsGetToManyRelatedOpts) (PerfPowerMetricsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PerfPowerMetricsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/perfPowerMetrics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FilterDeviceType.IsSet() {
		localVarQueryParams.Add("filter[deviceType]", parameterToString(localVarOptionals.FilterDeviceType.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterMetricType.IsSet() {
		localVarQueryParams.Add("filter[metricType]", parameterToString(localVarOptionals.FilterMetricType.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterPlatform.IsSet() {
		localVarQueryParams.Add("filter[platform]", parameterToString(localVarOptionals.FilterPlatform.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// BuildsApiBuildsPreReleaseVersionGetToOneRelatedOpts Optional parameters for the method 'BuildsPreReleaseVersionGetToOneRelated'
type BuildsApiBuildsPreReleaseVersionGetToOneRelatedOpts struct {
	FieldsPreReleaseVersions optional.Interface
}

/*
BuildsPreReleaseVersionGetToOneRelated Method for BuildsPreReleaseVersionGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *BuildsApiBuildsPreReleaseVersionGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsPreReleaseVersions" (optional.Interface of []string) -  the fields to include for returned resources of type preReleaseVersions
@return PrereleaseVersionResponse
*/
func (a *BuildsApiService) BuildsPreReleaseVersionGetToOneRelated(ctx _context.Context, id string, localVarOptionals *BuildsApiBuildsPreReleaseVersionGetToOneRelatedOpts) (PrereleaseVersionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PrereleaseVersionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}/preReleaseVersion"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsPreReleaseVersions.IsSet() {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(localVarOptionals.FieldsPreReleaseVersions.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
BuildsUpdateInstance Method for BuildsUpdateInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param buildUpdateRequest Build representation
@return BuildResponse
*/
func (a *BuildsApiService) BuildsUpdateInstance(ctx _context.Context, id string, buildUpdateRequest BuildUpdateRequest) (BuildResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/builds/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &buildUpdateRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
