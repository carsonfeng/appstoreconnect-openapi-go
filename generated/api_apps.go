/*
 * App Store Connect API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package appstoreopenapi

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// AppsApiService AppsApi service
type AppsApiService service

// AppsApiAppsAppInfosGetToManyRelatedOpts Optional parameters for the method 'AppsAppInfosGetToManyRelated'
type AppsApiAppsAppInfosGetToManyRelatedOpts struct {
	FieldsAppInfos             optional.Interface
	FieldsAppCategories        optional.Interface
	FieldsAppInfoLocalizations optional.Interface
	FieldsApps                 optional.Interface
	Limit                      optional.Int32
	Include                    optional.Interface
}

/*
AppsAppInfosGetToManyRelated Method for AppsAppInfosGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsAppInfosGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsAppInfos" (optional.Interface of []string) -  the fields to include for returned resources of type appInfos
 * @param "FieldsAppCategories" (optional.Interface of []string) -  the fields to include for returned resources of type appCategories
 * @param "FieldsAppInfoLocalizations" (optional.Interface of []string) -  the fields to include for returned resources of type appInfoLocalizations
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "Limit" (optional.Int32) -  maximum resources per page
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
@return AppInfosResponse
*/
func (a *AppsApiService) AppsAppInfosGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsAppInfosGetToManyRelatedOpts) (AppInfosResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppInfosResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/appInfos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsAppInfos.IsSet() {
		localVarQueryParams.Add("fields[appInfos]", parameterToString(localVarOptionals.FieldsAppInfos.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppCategories.IsSet() {
		localVarQueryParams.Add("fields[appCategories]", parameterToString(localVarOptionals.FieldsAppCategories.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppInfoLocalizations.IsSet() {
		localVarQueryParams.Add("fields[appInfoLocalizations]", parameterToString(localVarOptionals.FieldsAppInfoLocalizations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsAppStoreVersionsGetToManyRelatedOpts Optional parameters for the method 'AppsAppStoreVersionsGetToManyRelated'
type AppsApiAppsAppStoreVersionsGetToManyRelatedOpts struct {
	FilterAppStoreState                 optional.Interface
	FilterPlatform                      optional.Interface
	FilterVersionString                 optional.Interface
	FilterId                            optional.Interface
	FieldsIdfaDeclarations              optional.Interface
	FieldsAppStoreVersionLocalizations  optional.Interface
	FieldsRoutingAppCoverages           optional.Interface
	FieldsAppStoreVersionPhasedReleases optional.Interface
	FieldsAgeRatingDeclarations         optional.Interface
	FieldsAppStoreReviewDetails         optional.Interface
	FieldsAppStoreVersions              optional.Interface
	FieldsBuilds                        optional.Interface
	FieldsAppStoreVersionSubmissions    optional.Interface
	FieldsApps                          optional.Interface
	Limit                               optional.Int32
	Include                             optional.Interface
}

/*
AppsAppStoreVersionsGetToManyRelated Method for AppsAppStoreVersionsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsAppStoreVersionsGetToManyRelatedOpts - Optional Parameters:
 * @param "FilterAppStoreState" (optional.Interface of []string) -  filter by attribute 'appStoreState'
 * @param "FilterPlatform" (optional.Interface of []string) -  filter by attribute 'platform'
 * @param "FilterVersionString" (optional.Interface of []string) -  filter by attribute 'versionString'
 * @param "FilterId" (optional.Interface of []string) -  filter by id(s)
 * @param "FieldsIdfaDeclarations" (optional.Interface of []string) -  the fields to include for returned resources of type idfaDeclarations
 * @param "FieldsAppStoreVersionLocalizations" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersionLocalizations
 * @param "FieldsRoutingAppCoverages" (optional.Interface of []string) -  the fields to include for returned resources of type routingAppCoverages
 * @param "FieldsAppStoreVersionPhasedReleases" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersionPhasedReleases
 * @param "FieldsAgeRatingDeclarations" (optional.Interface of []string) -  the fields to include for returned resources of type ageRatingDeclarations
 * @param "FieldsAppStoreReviewDetails" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreReviewDetails
 * @param "FieldsAppStoreVersions" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersions
 * @param "FieldsBuilds" (optional.Interface of []string) -  the fields to include for returned resources of type builds
 * @param "FieldsAppStoreVersionSubmissions" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersionSubmissions
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "Limit" (optional.Int32) -  maximum resources per page
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
@return AppStoreVersionsResponse
*/
func (a *AppsApiService) AppsAppStoreVersionsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsAppStoreVersionsGetToManyRelatedOpts) (AppStoreVersionsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/appStoreVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FilterAppStoreState.IsSet() {
		localVarQueryParams.Add("filter[appStoreState]", parameterToString(localVarOptionals.FilterAppStoreState.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterPlatform.IsSet() {
		localVarQueryParams.Add("filter[platform]", parameterToString(localVarOptionals.FilterPlatform.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterVersionString.IsSet() {
		localVarQueryParams.Add("filter[versionString]", parameterToString(localVarOptionals.FilterVersionString.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterId.IsSet() {
		localVarQueryParams.Add("filter[id]", parameterToString(localVarOptionals.FilterId.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsIdfaDeclarations.IsSet() {
		localVarQueryParams.Add("fields[idfaDeclarations]", parameterToString(localVarOptionals.FieldsIdfaDeclarations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersionLocalizations.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersionLocalizations]", parameterToString(localVarOptionals.FieldsAppStoreVersionLocalizations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsRoutingAppCoverages.IsSet() {
		localVarQueryParams.Add("fields[routingAppCoverages]", parameterToString(localVarOptionals.FieldsRoutingAppCoverages.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersionPhasedReleases.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersionPhasedReleases]", parameterToString(localVarOptionals.FieldsAppStoreVersionPhasedReleases.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAgeRatingDeclarations.IsSet() {
		localVarQueryParams.Add("fields[ageRatingDeclarations]", parameterToString(localVarOptionals.FieldsAgeRatingDeclarations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreReviewDetails.IsSet() {
		localVarQueryParams.Add("fields[appStoreReviewDetails]", parameterToString(localVarOptionals.FieldsAppStoreReviewDetails.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersions.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(localVarOptionals.FieldsAppStoreVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBuilds.IsSet() {
		localVarQueryParams.Add("fields[builds]", parameterToString(localVarOptionals.FieldsBuilds.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersionSubmissions.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersionSubmissions]", parameterToString(localVarOptionals.FieldsAppStoreVersionSubmissions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsAvailableTerritoriesGetToManyRelatedOpts Optional parameters for the method 'AppsAvailableTerritoriesGetToManyRelated'
type AppsApiAppsAvailableTerritoriesGetToManyRelatedOpts struct {
	FieldsTerritories optional.Interface
	Limit             optional.Int32
}

/*
AppsAvailableTerritoriesGetToManyRelated Method for AppsAvailableTerritoriesGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsAvailableTerritoriesGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsTerritories" (optional.Interface of []string) -  the fields to include for returned resources of type territories
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return TerritoriesResponse
*/
func (a *AppsApiService) AppsAvailableTerritoriesGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsAvailableTerritoriesGetToManyRelatedOpts) (TerritoriesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TerritoriesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/availableTerritories"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsTerritories.IsSet() {
		localVarQueryParams.Add("fields[territories]", parameterToString(localVarOptionals.FieldsTerritories.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsBetaAppLocalizationsGetToManyRelatedOpts Optional parameters for the method 'AppsBetaAppLocalizationsGetToManyRelated'
type AppsApiAppsBetaAppLocalizationsGetToManyRelatedOpts struct {
	FieldsBetaAppLocalizations optional.Interface
	Limit                      optional.Int32
}

/*
AppsBetaAppLocalizationsGetToManyRelated Method for AppsBetaAppLocalizationsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsBetaAppLocalizationsGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsBetaAppLocalizations" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppLocalizations
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return BetaAppLocalizationsResponse
*/
func (a *AppsApiService) AppsBetaAppLocalizationsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsBetaAppLocalizationsGetToManyRelatedOpts) (BetaAppLocalizationsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaAppLocalizationsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/betaAppLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppLocalizations.IsSet() {
		localVarQueryParams.Add("fields[betaAppLocalizations]", parameterToString(localVarOptionals.FieldsBetaAppLocalizations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsBetaAppReviewDetailGetToOneRelatedOpts Optional parameters for the method 'AppsBetaAppReviewDetailGetToOneRelated'
type AppsApiAppsBetaAppReviewDetailGetToOneRelatedOpts struct {
	FieldsBetaAppReviewDetails optional.Interface
}

/*
AppsBetaAppReviewDetailGetToOneRelated Method for AppsBetaAppReviewDetailGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsBetaAppReviewDetailGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsBetaAppReviewDetails" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppReviewDetails
@return BetaAppReviewDetailResponse
*/
func (a *AppsApiService) AppsBetaAppReviewDetailGetToOneRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsBetaAppReviewDetailGetToOneRelatedOpts) (BetaAppReviewDetailResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaAppReviewDetailResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/betaAppReviewDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppReviewDetails.IsSet() {
		localVarQueryParams.Add("fields[betaAppReviewDetails]", parameterToString(localVarOptionals.FieldsBetaAppReviewDetails.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsBetaGroupsGetToManyRelatedOpts Optional parameters for the method 'AppsBetaGroupsGetToManyRelated'
type AppsApiAppsBetaGroupsGetToManyRelatedOpts struct {
	FieldsBetaGroups optional.Interface
	Limit            optional.Int32
}

/*
AppsBetaGroupsGetToManyRelated Method for AppsBetaGroupsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsBetaGroupsGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsBetaGroups" (optional.Interface of []string) -  the fields to include for returned resources of type betaGroups
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return BetaGroupsResponse
*/
func (a *AppsApiService) AppsBetaGroupsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsBetaGroupsGetToManyRelatedOpts) (BetaGroupsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaGroupsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBetaGroups.IsSet() {
		localVarQueryParams.Add("fields[betaGroups]", parameterToString(localVarOptionals.FieldsBetaGroups.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsBetaLicenseAgreementGetToOneRelatedOpts Optional parameters for the method 'AppsBetaLicenseAgreementGetToOneRelated'
type AppsApiAppsBetaLicenseAgreementGetToOneRelatedOpts struct {
	FieldsBetaLicenseAgreements optional.Interface
}

/*
AppsBetaLicenseAgreementGetToOneRelated Method for AppsBetaLicenseAgreementGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsBetaLicenseAgreementGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsBetaLicenseAgreements" (optional.Interface of []string) -  the fields to include for returned resources of type betaLicenseAgreements
@return BetaLicenseAgreementResponse
*/
func (a *AppsApiService) AppsBetaLicenseAgreementGetToOneRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsBetaLicenseAgreementGetToOneRelatedOpts) (BetaLicenseAgreementResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaLicenseAgreementResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/betaLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBetaLicenseAgreements.IsSet() {
		localVarQueryParams.Add("fields[betaLicenseAgreements]", parameterToString(localVarOptionals.FieldsBetaLicenseAgreements.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
AppsBetaTestersDeleteToManyRelationship Method for AppsBetaTestersDeleteToManyRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param appBetaTestersLinkagesRequest List of related linkages
*/
func (a *AppsApiService) AppsBetaTestersDeleteToManyRelationship(ctx _context.Context, id string, appBetaTestersLinkagesRequest AppBetaTestersLinkagesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/relationships/betaTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &appBetaTestersLinkagesRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// AppsApiAppsBuildsGetToManyRelatedOpts Optional parameters for the method 'AppsBuildsGetToManyRelated'
type AppsApiAppsBuildsGetToManyRelatedOpts struct {
	FieldsBuilds optional.Interface
	Limit        optional.Int32
}

/*
AppsBuildsGetToManyRelated Method for AppsBuildsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsBuildsGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsBuilds" (optional.Interface of []string) -  the fields to include for returned resources of type builds
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return BuildsResponse
*/
func (a *AppsApiService) AppsBuildsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsBuildsGetToManyRelatedOpts) (BuildsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsBuilds.IsSet() {
		localVarQueryParams.Add("fields[builds]", parameterToString(localVarOptionals.FieldsBuilds.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsEndUserLicenseAgreementGetToOneRelatedOpts Optional parameters for the method 'AppsEndUserLicenseAgreementGetToOneRelated'
type AppsApiAppsEndUserLicenseAgreementGetToOneRelatedOpts struct {
	FieldsEndUserLicenseAgreements optional.Interface
}

/*
AppsEndUserLicenseAgreementGetToOneRelated Method for AppsEndUserLicenseAgreementGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsEndUserLicenseAgreementGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsEndUserLicenseAgreements" (optional.Interface of []string) -  the fields to include for returned resources of type endUserLicenseAgreements
@return EndUserLicenseAgreementResponse
*/
func (a *AppsApiService) AppsEndUserLicenseAgreementGetToOneRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsEndUserLicenseAgreementGetToOneRelatedOpts) (EndUserLicenseAgreementResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EndUserLicenseAgreementResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/endUserLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsEndUserLicenseAgreements.IsSet() {
		localVarQueryParams.Add("fields[endUserLicenseAgreements]", parameterToString(localVarOptionals.FieldsEndUserLicenseAgreements.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedOpts Optional parameters for the method 'AppsGameCenterEnabledVersionsGetToManyRelated'
type AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedOpts struct {
	FilterPlatform                  optional.Interface
	FilterVersionString             optional.Interface
	FilterId                        optional.Interface
	Sort                            optional.Interface
	FieldsGameCenterEnabledVersions optional.Interface
	FieldsApps                      optional.Interface
	Limit                           optional.Int32
	Include                         optional.Interface
}

/*
AppsGameCenterEnabledVersionsGetToManyRelated Method for AppsGameCenterEnabledVersionsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedOpts - Optional Parameters:
 * @param "FilterPlatform" (optional.Interface of []string) -  filter by attribute 'platform'
 * @param "FilterVersionString" (optional.Interface of []string) -  filter by attribute 'versionString'
 * @param "FilterId" (optional.Interface of []string) -  filter by id(s)
 * @param "Sort" (optional.Interface of []string) -  comma-separated list of sort expressions; resources will be sorted as specified
 * @param "FieldsGameCenterEnabledVersions" (optional.Interface of []string) -  the fields to include for returned resources of type gameCenterEnabledVersions
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "Limit" (optional.Int32) -  maximum resources per page
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
@return GameCenterEnabledVersionsResponse
*/
func (a *AppsApiService) AppsGameCenterEnabledVersionsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsGameCenterEnabledVersionsGetToManyRelatedOpts) (GameCenterEnabledVersionsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GameCenterEnabledVersionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/gameCenterEnabledVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FilterPlatform.IsSet() {
		localVarQueryParams.Add("filter[platform]", parameterToString(localVarOptionals.FilterPlatform.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterVersionString.IsSet() {
		localVarQueryParams.Add("filter[versionString]", parameterToString(localVarOptionals.FilterVersionString.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterId.IsSet() {
		localVarQueryParams.Add("filter[id]", parameterToString(localVarOptionals.FilterId.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsGameCenterEnabledVersions.IsSet() {
		localVarQueryParams.Add("fields[gameCenterEnabledVersions]", parameterToString(localVarOptionals.FieldsGameCenterEnabledVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsGetCollectionOpts Optional parameters for the method 'AppsGetCollection'
type AppsApiAppsGetCollectionOpts struct {
	FilterAppStoreVersionsAppStoreState optional.Interface
	FilterAppStoreVersionsPlatform      optional.Interface
	FilterBundleId                      optional.Interface
	FilterName                          optional.Interface
	FilterSku                           optional.Interface
	FilterAppStoreVersions              optional.Interface
	FilterId                            optional.Interface
	ExistsGameCenterEnabledVersions     optional.Interface
	Sort                                optional.Interface
	FieldsApps                          optional.Interface
	Limit                               optional.Int32
	Include                             optional.Interface
	FieldsBetaGroups                    optional.Interface
	FieldsPerfPowerMetrics              optional.Interface
	FieldsAppInfos                      optional.Interface
	FieldsAppPreOrders                  optional.Interface
	FieldsPreReleaseVersions            optional.Interface
	FieldsAppPrices                     optional.Interface
	FieldsInAppPurchases                optional.Interface
	FieldsBetaAppReviewDetails          optional.Interface
	FieldsTerritories                   optional.Interface
	FieldsGameCenterEnabledVersions     optional.Interface
	FieldsAppStoreVersions              optional.Interface
	FieldsBuilds                        optional.Interface
	FieldsBetaAppLocalizations          optional.Interface
	FieldsBetaLicenseAgreements         optional.Interface
	FieldsEndUserLicenseAgreements      optional.Interface
	LimitAppInfos                       optional.Int32
	LimitAppStoreVersions               optional.Int32
	LimitAvailableTerritories           optional.Int32
	LimitBetaAppLocalizations           optional.Int32
	LimitBetaGroups                     optional.Int32
	LimitBuilds                         optional.Int32
	LimitGameCenterEnabledVersions      optional.Int32
	LimitInAppPurchases                 optional.Int32
	LimitPreReleaseVersions             optional.Int32
	LimitPrices                         optional.Int32
}

/*
AppsGetCollection Method for AppsGetCollection
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AppsApiAppsGetCollectionOpts - Optional Parameters:
 * @param "FilterAppStoreVersionsAppStoreState" (optional.Interface of []string) -  filter by attribute 'appStoreVersions.appStoreState'
 * @param "FilterAppStoreVersionsPlatform" (optional.Interface of []string) -  filter by attribute 'appStoreVersions.platform'
 * @param "FilterBundleId" (optional.Interface of []string) -  filter by attribute 'bundleId'
 * @param "FilterName" (optional.Interface of []string) -  filter by attribute 'name'
 * @param "FilterSku" (optional.Interface of []string) -  filter by attribute 'sku'
 * @param "FilterAppStoreVersions" (optional.Interface of []string) -  filter by id(s) of related 'appStoreVersions'
 * @param "FilterId" (optional.Interface of []string) -  filter by id(s)
 * @param "ExistsGameCenterEnabledVersions" (optional.Interface of []string) -  filter by existence or non-existence of related 'gameCenterEnabledVersions'
 * @param "Sort" (optional.Interface of []string) -  comma-separated list of sort expressions; resources will be sorted as specified
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "Limit" (optional.Int32) -  maximum resources per page
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
 * @param "FieldsBetaGroups" (optional.Interface of []string) -  the fields to include for returned resources of type betaGroups
 * @param "FieldsPerfPowerMetrics" (optional.Interface of []string) -  the fields to include for returned resources of type perfPowerMetrics
 * @param "FieldsAppInfos" (optional.Interface of []string) -  the fields to include for returned resources of type appInfos
 * @param "FieldsAppPreOrders" (optional.Interface of []string) -  the fields to include for returned resources of type appPreOrders
 * @param "FieldsPreReleaseVersions" (optional.Interface of []string) -  the fields to include for returned resources of type preReleaseVersions
 * @param "FieldsAppPrices" (optional.Interface of []string) -  the fields to include for returned resources of type appPrices
 * @param "FieldsInAppPurchases" (optional.Interface of []string) -  the fields to include for returned resources of type inAppPurchases
 * @param "FieldsBetaAppReviewDetails" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppReviewDetails
 * @param "FieldsTerritories" (optional.Interface of []string) -  the fields to include for returned resources of type territories
 * @param "FieldsGameCenterEnabledVersions" (optional.Interface of []string) -  the fields to include for returned resources of type gameCenterEnabledVersions
 * @param "FieldsAppStoreVersions" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersions
 * @param "FieldsBuilds" (optional.Interface of []string) -  the fields to include for returned resources of type builds
 * @param "FieldsBetaAppLocalizations" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppLocalizations
 * @param "FieldsBetaLicenseAgreements" (optional.Interface of []string) -  the fields to include for returned resources of type betaLicenseAgreements
 * @param "FieldsEndUserLicenseAgreements" (optional.Interface of []string) -  the fields to include for returned resources of type endUserLicenseAgreements
 * @param "LimitAppInfos" (optional.Int32) -  maximum number of related appInfos returned (when they are included)
 * @param "LimitAppStoreVersions" (optional.Int32) -  maximum number of related appStoreVersions returned (when they are included)
 * @param "LimitAvailableTerritories" (optional.Int32) -  maximum number of related availableTerritories returned (when they are included)
 * @param "LimitBetaAppLocalizations" (optional.Int32) -  maximum number of related betaAppLocalizations returned (when they are included)
 * @param "LimitBetaGroups" (optional.Int32) -  maximum number of related betaGroups returned (when they are included)
 * @param "LimitBuilds" (optional.Int32) -  maximum number of related builds returned (when they are included)
 * @param "LimitGameCenterEnabledVersions" (optional.Int32) -  maximum number of related gameCenterEnabledVersions returned (when they are included)
 * @param "LimitInAppPurchases" (optional.Int32) -  maximum number of related inAppPurchases returned (when they are included)
 * @param "LimitPreReleaseVersions" (optional.Int32) -  maximum number of related preReleaseVersions returned (when they are included)
 * @param "LimitPrices" (optional.Int32) -  maximum number of related prices returned (when they are included)
@return AppsResponse
*/
func (a *AppsApiService) AppsGetCollection(ctx _context.Context, localVarOptionals *AppsApiAppsGetCollectionOpts) (AppsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FilterAppStoreVersionsAppStoreState.IsSet() {
		localVarQueryParams.Add("filter[appStoreVersions.appStoreState]", parameterToString(localVarOptionals.FilterAppStoreVersionsAppStoreState.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterAppStoreVersionsPlatform.IsSet() {
		localVarQueryParams.Add("filter[appStoreVersions.platform]", parameterToString(localVarOptionals.FilterAppStoreVersionsPlatform.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterBundleId.IsSet() {
		localVarQueryParams.Add("filter[bundleId]", parameterToString(localVarOptionals.FilterBundleId.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterName.IsSet() {
		localVarQueryParams.Add("filter[name]", parameterToString(localVarOptionals.FilterName.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterSku.IsSet() {
		localVarQueryParams.Add("filter[sku]", parameterToString(localVarOptionals.FilterSku.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterAppStoreVersions.IsSet() {
		localVarQueryParams.Add("filter[appStoreVersions]", parameterToString(localVarOptionals.FilterAppStoreVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterId.IsSet() {
		localVarQueryParams.Add("filter[id]", parameterToString(localVarOptionals.FilterId.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.ExistsGameCenterEnabledVersions.IsSet() {
		localVarQueryParams.Add("exists[gameCenterEnabledVersions]", parameterToString(localVarOptionals.ExistsGameCenterEnabledVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaGroups.IsSet() {
		localVarQueryParams.Add("fields[betaGroups]", parameterToString(localVarOptionals.FieldsBetaGroups.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsPerfPowerMetrics.IsSet() {
		localVarQueryParams.Add("fields[perfPowerMetrics]", parameterToString(localVarOptionals.FieldsPerfPowerMetrics.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppInfos.IsSet() {
		localVarQueryParams.Add("fields[appInfos]", parameterToString(localVarOptionals.FieldsAppInfos.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppPreOrders.IsSet() {
		localVarQueryParams.Add("fields[appPreOrders]", parameterToString(localVarOptionals.FieldsAppPreOrders.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsPreReleaseVersions.IsSet() {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(localVarOptionals.FieldsPreReleaseVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppPrices.IsSet() {
		localVarQueryParams.Add("fields[appPrices]", parameterToString(localVarOptionals.FieldsAppPrices.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsInAppPurchases.IsSet() {
		localVarQueryParams.Add("fields[inAppPurchases]", parameterToString(localVarOptionals.FieldsInAppPurchases.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppReviewDetails.IsSet() {
		localVarQueryParams.Add("fields[betaAppReviewDetails]", parameterToString(localVarOptionals.FieldsBetaAppReviewDetails.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsTerritories.IsSet() {
		localVarQueryParams.Add("fields[territories]", parameterToString(localVarOptionals.FieldsTerritories.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsGameCenterEnabledVersions.IsSet() {
		localVarQueryParams.Add("fields[gameCenterEnabledVersions]", parameterToString(localVarOptionals.FieldsGameCenterEnabledVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersions.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(localVarOptionals.FieldsAppStoreVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBuilds.IsSet() {
		localVarQueryParams.Add("fields[builds]", parameterToString(localVarOptionals.FieldsBuilds.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppLocalizations.IsSet() {
		localVarQueryParams.Add("fields[betaAppLocalizations]", parameterToString(localVarOptionals.FieldsBetaAppLocalizations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaLicenseAgreements.IsSet() {
		localVarQueryParams.Add("fields[betaLicenseAgreements]", parameterToString(localVarOptionals.FieldsBetaLicenseAgreements.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsEndUserLicenseAgreements.IsSet() {
		localVarQueryParams.Add("fields[endUserLicenseAgreements]", parameterToString(localVarOptionals.FieldsEndUserLicenseAgreements.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.LimitAppInfos.IsSet() {
		localVarQueryParams.Add("limit[appInfos]", parameterToString(localVarOptionals.LimitAppInfos.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitAppStoreVersions.IsSet() {
		localVarQueryParams.Add("limit[appStoreVersions]", parameterToString(localVarOptionals.LimitAppStoreVersions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitAvailableTerritories.IsSet() {
		localVarQueryParams.Add("limit[availableTerritories]", parameterToString(localVarOptionals.LimitAvailableTerritories.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitBetaAppLocalizations.IsSet() {
		localVarQueryParams.Add("limit[betaAppLocalizations]", parameterToString(localVarOptionals.LimitBetaAppLocalizations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitBetaGroups.IsSet() {
		localVarQueryParams.Add("limit[betaGroups]", parameterToString(localVarOptionals.LimitBetaGroups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitBuilds.IsSet() {
		localVarQueryParams.Add("limit[builds]", parameterToString(localVarOptionals.LimitBuilds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitGameCenterEnabledVersions.IsSet() {
		localVarQueryParams.Add("limit[gameCenterEnabledVersions]", parameterToString(localVarOptionals.LimitGameCenterEnabledVersions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitInAppPurchases.IsSet() {
		localVarQueryParams.Add("limit[inAppPurchases]", parameterToString(localVarOptionals.LimitInAppPurchases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitPreReleaseVersions.IsSet() {
		localVarQueryParams.Add("limit[preReleaseVersions]", parameterToString(localVarOptionals.LimitPreReleaseVersions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitPrices.IsSet() {
		localVarQueryParams.Add("limit[prices]", parameterToString(localVarOptionals.LimitPrices.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsGetInstanceOpts Optional parameters for the method 'AppsGetInstance'
type AppsApiAppsGetInstanceOpts struct {
	FieldsApps                      optional.Interface
	Include                         optional.Interface
	FieldsBetaGroups                optional.Interface
	FieldsPerfPowerMetrics          optional.Interface
	FieldsAppInfos                  optional.Interface
	FieldsAppPreOrders              optional.Interface
	FieldsPreReleaseVersions        optional.Interface
	FieldsAppPrices                 optional.Interface
	FieldsInAppPurchases            optional.Interface
	FieldsBetaAppReviewDetails      optional.Interface
	FieldsTerritories               optional.Interface
	FieldsGameCenterEnabledVersions optional.Interface
	FieldsAppStoreVersions          optional.Interface
	FieldsBuilds                    optional.Interface
	FieldsBetaAppLocalizations      optional.Interface
	FieldsBetaLicenseAgreements     optional.Interface
	FieldsEndUserLicenseAgreements  optional.Interface
	LimitAppInfos                   optional.Int32
	LimitAppStoreVersions           optional.Int32
	LimitAvailableTerritories       optional.Int32
	LimitBetaAppLocalizations       optional.Int32
	LimitBetaGroups                 optional.Int32
	LimitBuilds                     optional.Int32
	LimitGameCenterEnabledVersions  optional.Int32
	LimitInAppPurchases             optional.Int32
	LimitPreReleaseVersions         optional.Int32
	LimitPrices                     optional.Int32
}

/*
AppsGetInstance Method for AppsGetInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsGetInstanceOpts - Optional Parameters:
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
 * @param "FieldsBetaGroups" (optional.Interface of []string) -  the fields to include for returned resources of type betaGroups
 * @param "FieldsPerfPowerMetrics" (optional.Interface of []string) -  the fields to include for returned resources of type perfPowerMetrics
 * @param "FieldsAppInfos" (optional.Interface of []string) -  the fields to include for returned resources of type appInfos
 * @param "FieldsAppPreOrders" (optional.Interface of []string) -  the fields to include for returned resources of type appPreOrders
 * @param "FieldsPreReleaseVersions" (optional.Interface of []string) -  the fields to include for returned resources of type preReleaseVersions
 * @param "FieldsAppPrices" (optional.Interface of []string) -  the fields to include for returned resources of type appPrices
 * @param "FieldsInAppPurchases" (optional.Interface of []string) -  the fields to include for returned resources of type inAppPurchases
 * @param "FieldsBetaAppReviewDetails" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppReviewDetails
 * @param "FieldsTerritories" (optional.Interface of []string) -  the fields to include for returned resources of type territories
 * @param "FieldsGameCenterEnabledVersions" (optional.Interface of []string) -  the fields to include for returned resources of type gameCenterEnabledVersions
 * @param "FieldsAppStoreVersions" (optional.Interface of []string) -  the fields to include for returned resources of type appStoreVersions
 * @param "FieldsBuilds" (optional.Interface of []string) -  the fields to include for returned resources of type builds
 * @param "FieldsBetaAppLocalizations" (optional.Interface of []string) -  the fields to include for returned resources of type betaAppLocalizations
 * @param "FieldsBetaLicenseAgreements" (optional.Interface of []string) -  the fields to include for returned resources of type betaLicenseAgreements
 * @param "FieldsEndUserLicenseAgreements" (optional.Interface of []string) -  the fields to include for returned resources of type endUserLicenseAgreements
 * @param "LimitAppInfos" (optional.Int32) -  maximum number of related appInfos returned (when they are included)
 * @param "LimitAppStoreVersions" (optional.Int32) -  maximum number of related appStoreVersions returned (when they are included)
 * @param "LimitAvailableTerritories" (optional.Int32) -  maximum number of related availableTerritories returned (when they are included)
 * @param "LimitBetaAppLocalizations" (optional.Int32) -  maximum number of related betaAppLocalizations returned (when they are included)
 * @param "LimitBetaGroups" (optional.Int32) -  maximum number of related betaGroups returned (when they are included)
 * @param "LimitBuilds" (optional.Int32) -  maximum number of related builds returned (when they are included)
 * @param "LimitGameCenterEnabledVersions" (optional.Int32) -  maximum number of related gameCenterEnabledVersions returned (when they are included)
 * @param "LimitInAppPurchases" (optional.Int32) -  maximum number of related inAppPurchases returned (when they are included)
 * @param "LimitPreReleaseVersions" (optional.Int32) -  maximum number of related preReleaseVersions returned (when they are included)
 * @param "LimitPrices" (optional.Int32) -  maximum number of related prices returned (when they are included)
@return AppResponse
*/
func (a *AppsApiService) AppsGetInstance(ctx _context.Context, id string, localVarOptionals *AppsApiAppsGetInstanceOpts) (AppResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaGroups.IsSet() {
		localVarQueryParams.Add("fields[betaGroups]", parameterToString(localVarOptionals.FieldsBetaGroups.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsPerfPowerMetrics.IsSet() {
		localVarQueryParams.Add("fields[perfPowerMetrics]", parameterToString(localVarOptionals.FieldsPerfPowerMetrics.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppInfos.IsSet() {
		localVarQueryParams.Add("fields[appInfos]", parameterToString(localVarOptionals.FieldsAppInfos.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppPreOrders.IsSet() {
		localVarQueryParams.Add("fields[appPreOrders]", parameterToString(localVarOptionals.FieldsAppPreOrders.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsPreReleaseVersions.IsSet() {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(localVarOptionals.FieldsPreReleaseVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppPrices.IsSet() {
		localVarQueryParams.Add("fields[appPrices]", parameterToString(localVarOptionals.FieldsAppPrices.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsInAppPurchases.IsSet() {
		localVarQueryParams.Add("fields[inAppPurchases]", parameterToString(localVarOptionals.FieldsInAppPurchases.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppReviewDetails.IsSet() {
		localVarQueryParams.Add("fields[betaAppReviewDetails]", parameterToString(localVarOptionals.FieldsBetaAppReviewDetails.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsTerritories.IsSet() {
		localVarQueryParams.Add("fields[territories]", parameterToString(localVarOptionals.FieldsTerritories.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsGameCenterEnabledVersions.IsSet() {
		localVarQueryParams.Add("fields[gameCenterEnabledVersions]", parameterToString(localVarOptionals.FieldsGameCenterEnabledVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppStoreVersions.IsSet() {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(localVarOptionals.FieldsAppStoreVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBuilds.IsSet() {
		localVarQueryParams.Add("fields[builds]", parameterToString(localVarOptionals.FieldsBuilds.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaAppLocalizations.IsSet() {
		localVarQueryParams.Add("fields[betaAppLocalizations]", parameterToString(localVarOptionals.FieldsBetaAppLocalizations.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsBetaLicenseAgreements.IsSet() {
		localVarQueryParams.Add("fields[betaLicenseAgreements]", parameterToString(localVarOptionals.FieldsBetaLicenseAgreements.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsEndUserLicenseAgreements.IsSet() {
		localVarQueryParams.Add("fields[endUserLicenseAgreements]", parameterToString(localVarOptionals.FieldsEndUserLicenseAgreements.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.LimitAppInfos.IsSet() {
		localVarQueryParams.Add("limit[appInfos]", parameterToString(localVarOptionals.LimitAppInfos.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitAppStoreVersions.IsSet() {
		localVarQueryParams.Add("limit[appStoreVersions]", parameterToString(localVarOptionals.LimitAppStoreVersions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitAvailableTerritories.IsSet() {
		localVarQueryParams.Add("limit[availableTerritories]", parameterToString(localVarOptionals.LimitAvailableTerritories.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitBetaAppLocalizations.IsSet() {
		localVarQueryParams.Add("limit[betaAppLocalizations]", parameterToString(localVarOptionals.LimitBetaAppLocalizations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitBetaGroups.IsSet() {
		localVarQueryParams.Add("limit[betaGroups]", parameterToString(localVarOptionals.LimitBetaGroups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitBuilds.IsSet() {
		localVarQueryParams.Add("limit[builds]", parameterToString(localVarOptionals.LimitBuilds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitGameCenterEnabledVersions.IsSet() {
		localVarQueryParams.Add("limit[gameCenterEnabledVersions]", parameterToString(localVarOptionals.LimitGameCenterEnabledVersions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitInAppPurchases.IsSet() {
		localVarQueryParams.Add("limit[inAppPurchases]", parameterToString(localVarOptionals.LimitInAppPurchases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitPreReleaseVersions.IsSet() {
		localVarQueryParams.Add("limit[preReleaseVersions]", parameterToString(localVarOptionals.LimitPreReleaseVersions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LimitPrices.IsSet() {
		localVarQueryParams.Add("limit[prices]", parameterToString(localVarOptionals.LimitPrices.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsInAppPurchasesGetToManyRelatedOpts Optional parameters for the method 'AppsInAppPurchasesGetToManyRelated'
type AppsApiAppsInAppPurchasesGetToManyRelatedOpts struct {
	FilterInAppPurchaseType optional.Interface
	FilterCanBeSubmitted    optional.Interface
	Sort                    optional.Interface
	FieldsInAppPurchases    optional.Interface
	FieldsApps              optional.Interface
	Limit                   optional.Int32
	Include                 optional.Interface
}

/*
AppsInAppPurchasesGetToManyRelated Method for AppsInAppPurchasesGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsInAppPurchasesGetToManyRelatedOpts - Optional Parameters:
 * @param "FilterInAppPurchaseType" (optional.Interface of []string) -  filter by attribute 'inAppPurchaseType'
 * @param "FilterCanBeSubmitted" (optional.Interface of []string) -  filter by canBeSubmitted
 * @param "Sort" (optional.Interface of []string) -  comma-separated list of sort expressions; resources will be sorted as specified
 * @param "FieldsInAppPurchases" (optional.Interface of []string) -  the fields to include for returned resources of type inAppPurchases
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "Limit" (optional.Int32) -  maximum resources per page
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
@return InAppPurchasesResponse
*/
func (a *AppsApiService) AppsInAppPurchasesGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsInAppPurchasesGetToManyRelatedOpts) (InAppPurchasesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InAppPurchasesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/inAppPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FilterInAppPurchaseType.IsSet() {
		localVarQueryParams.Add("filter[inAppPurchaseType]", parameterToString(localVarOptionals.FilterInAppPurchaseType.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterCanBeSubmitted.IsSet() {
		localVarQueryParams.Add("filter[canBeSubmitted]", parameterToString(localVarOptionals.FilterCanBeSubmitted.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsInAppPurchases.IsSet() {
		localVarQueryParams.Add("fields[inAppPurchases]", parameterToString(localVarOptionals.FieldsInAppPurchases.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsPerfPowerMetricsGetToManyRelatedOpts Optional parameters for the method 'AppsPerfPowerMetricsGetToManyRelated'
type AppsApiAppsPerfPowerMetricsGetToManyRelatedOpts struct {
	FilterDeviceType optional.Interface
	FilterMetricType optional.Interface
	FilterPlatform   optional.Interface
}

/*
AppsPerfPowerMetricsGetToManyRelated Method for AppsPerfPowerMetricsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsPerfPowerMetricsGetToManyRelatedOpts - Optional Parameters:
 * @param "FilterDeviceType" (optional.Interface of []string) -  filter by attribute 'deviceType'
 * @param "FilterMetricType" (optional.Interface of []string) -  filter by attribute 'metricType'
 * @param "FilterPlatform" (optional.Interface of []string) -  filter by attribute 'platform'
@return PerfPowerMetricsResponse
*/
func (a *AppsApiService) AppsPerfPowerMetricsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsPerfPowerMetricsGetToManyRelatedOpts) (PerfPowerMetricsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PerfPowerMetricsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/perfPowerMetrics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FilterDeviceType.IsSet() {
		localVarQueryParams.Add("filter[deviceType]", parameterToString(localVarOptionals.FilterDeviceType.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterMetricType.IsSet() {
		localVarQueryParams.Add("filter[metricType]", parameterToString(localVarOptionals.FilterMetricType.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FilterPlatform.IsSet() {
		localVarQueryParams.Add("filter[platform]", parameterToString(localVarOptionals.FilterPlatform.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsPreOrderGetToOneRelatedOpts Optional parameters for the method 'AppsPreOrderGetToOneRelated'
type AppsApiAppsPreOrderGetToOneRelatedOpts struct {
	FieldsAppPreOrders optional.Interface
}

/*
AppsPreOrderGetToOneRelated Method for AppsPreOrderGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsPreOrderGetToOneRelatedOpts - Optional Parameters:
 * @param "FieldsAppPreOrders" (optional.Interface of []string) -  the fields to include for returned resources of type appPreOrders
@return AppPreOrderResponse
*/
func (a *AppsApiService) AppsPreOrderGetToOneRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsPreOrderGetToOneRelatedOpts) (AppPreOrderResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppPreOrderResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/preOrder"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsAppPreOrders.IsSet() {
		localVarQueryParams.Add("fields[appPreOrders]", parameterToString(localVarOptionals.FieldsAppPreOrders.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsPreReleaseVersionsGetToManyRelatedOpts Optional parameters for the method 'AppsPreReleaseVersionsGetToManyRelated'
type AppsApiAppsPreReleaseVersionsGetToManyRelatedOpts struct {
	FieldsPreReleaseVersions optional.Interface
	Limit                    optional.Int32
}

/*
AppsPreReleaseVersionsGetToManyRelated Method for AppsPreReleaseVersionsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsPreReleaseVersionsGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsPreReleaseVersions" (optional.Interface of []string) -  the fields to include for returned resources of type preReleaseVersions
 * @param "Limit" (optional.Int32) -  maximum resources per page
@return PreReleaseVersionsResponse
*/
func (a *AppsApiService) AppsPreReleaseVersionsGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsPreReleaseVersionsGetToManyRelatedOpts) (PreReleaseVersionsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PreReleaseVersionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/preReleaseVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsPreReleaseVersions.IsSet() {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(localVarOptionals.FieldsPreReleaseVersions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AppsApiAppsPricesGetToManyRelatedOpts Optional parameters for the method 'AppsPricesGetToManyRelated'
type AppsApiAppsPricesGetToManyRelatedOpts struct {
	FieldsAppPrices     optional.Interface
	FieldsAppPriceTiers optional.Interface
	FieldsApps          optional.Interface
	Limit               optional.Int32
	Include             optional.Interface
}

/*
AppsPricesGetToManyRelated Method for AppsPricesGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param optional nil or *AppsApiAppsPricesGetToManyRelatedOpts - Optional Parameters:
 * @param "FieldsAppPrices" (optional.Interface of []string) -  the fields to include for returned resources of type appPrices
 * @param "FieldsAppPriceTiers" (optional.Interface of []string) -  the fields to include for returned resources of type appPriceTiers
 * @param "FieldsApps" (optional.Interface of []string) -  the fields to include for returned resources of type apps
 * @param "Limit" (optional.Int32) -  maximum resources per page
 * @param "Include" (optional.Interface of []string) -  comma-separated list of relationships to include
@return AppPricesResponse
*/
func (a *AppsApiService) AppsPricesGetToManyRelated(ctx _context.Context, id string, localVarOptionals *AppsApiAppsPricesGetToManyRelatedOpts) (AppPricesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppPricesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FieldsAppPrices.IsSet() {
		localVarQueryParams.Add("fields[appPrices]", parameterToString(localVarOptionals.FieldsAppPrices.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsAppPriceTiers.IsSet() {
		localVarQueryParams.Add("fields[appPriceTiers]", parameterToString(localVarOptionals.FieldsAppPriceTiers.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.FieldsApps.IsSet() {
		localVarQueryParams.Add("fields[apps]", parameterToString(localVarOptionals.FieldsApps.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
AppsUpdateInstance Method for AppsUpdateInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @param appUpdateRequest App representation
@return AppResponse
*/
func (a *AppsApiService) AppsUpdateInstance(ctx _context.Context, id string, appUpdateRequest AppUpdateRequest) (AppResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &appUpdateRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
